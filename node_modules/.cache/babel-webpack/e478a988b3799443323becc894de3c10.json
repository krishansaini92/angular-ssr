{"ast":null,"code":"import _classCallCheck from \"/Users/krishan/Documents/vmware/angular-ssr/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/krishan/Documents/vmware/angular-ssr/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/krishan/Documents/vmware/angular-ssr/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/krishan/Documents/vmware/angular-ssr/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/krishan/Documents/vmware/angular-ssr/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/krishan/Documents/vmware/angular-ssr/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * The main LitElement module, which defines the [[`LitElement`]] base class and\n * related APIs.\n *\n *  LitElement components can define a template and a set of observed\n * properties. Changing an observed property triggers a re-render of the\n * element.\n *\n *  Import [[`LitElement`]] and [[`html`]] from this module to create a\n * component:\n *\n *  ```js\n * import {LitElement, html} from 'lit-element';\n *\n * class MyElement extends LitElement {\n *\n *   // Declare observed properties\n *   static get properties() {\n *     return {\n *       adjective: {}\n *     }\n *   }\n *\n *   constructor() {\n *     this.adjective = 'awesome';\n *   }\n *\n *   // Define the element's template\n *   render() {\n *     return html`<p>your ${adjective} template here</p>`;\n *   }\n * }\n *\n * customElements.define('my-element', MyElement);\n * ```\n *\n * `LitElement` extends [[`UpdatingElement`]] and adds lit-html templating.\n * The `UpdatingElement` class is provided for users that want to build\n * their own custom element base classes that don't use lit-html.\n *\n * @packageDocumentation\n */\nimport { render } from 'lit-html/lib/shady-render.js';\nimport { UpdatingElement } from './lib/updating-element.js';\nexport * from './lib/updating-element.js';\nexport * from './lib/decorators.js';\nexport { html, svg, TemplateResult, SVGTemplateResult } from 'lit-html/lit-html.js';\nimport { supportsAdoptingStyleSheets, unsafeCSS } from './lib/css-tag.js';\nexport * from './lib/css-tag.js'; // IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for LitElement usage.\n// TODO(justinfagnani): inject version number at build time\n\n(window['litElementVersions'] || (window['litElementVersions'] = [])).push('2.4.0');\n/**\n * Sentinal value used to avoid calling lit-html's render function when\n * subclasses do not implement `render`\n */\n\nvar renderNotImplemented = {};\n/**\n * Base element class that manages element properties and attributes, and\n * renders a lit-html template.\n *\n * To define a component, subclass `LitElement` and implement a\n * `render` method to provide the component's template. Define properties\n * using the [[`properties`]] property or the [[`property`]] decorator.\n */\n\nexport var LitElement = /*@__PURE__*/function () {\n  var LitElement = /*#__PURE__*/function (_UpdatingElement) {\n    _inherits(LitElement, _UpdatingElement);\n\n    var _super = _createSuper(LitElement);\n\n    function LitElement() {\n      _classCallCheck(this, LitElement);\n\n      return _super.apply(this, arguments);\n    }\n\n    _createClass(LitElement, [{\n      key: \"initialize\",\n      value:\n      /**\n       * Performs element initialization. By default this calls\n       * [[`createRenderRoot`]] to create the element [[`renderRoot`]] node and\n       * captures any pre-set values for registered properties.\n       */\n      function initialize() {\n        _get(_getPrototypeOf(LitElement.prototype), \"initialize\", this).call(this);\n\n        this.constructor._getUniqueStyles();\n\n        this.renderRoot = this.createRenderRoot(); // Note, if renderRoot is not a shadowRoot, styles would/could apply to the\n        // element's getRootNode(). While this could be done, we're choosing not to\n        // support this now since it would require different logic around de-duping.\n\n        if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {\n          this.adoptStyles();\n        }\n      }\n      /**\n       * Returns the node into which the element should render and by default\n       * creates and returns an open shadowRoot. Implement to customize where the\n       * element's DOM is rendered. For example, to render into the element's\n       * childNodes, return `this`.\n       * @returns {Element|DocumentFragment} Returns a node into which to render.\n       */\n\n    }, {\n      key: \"createRenderRoot\",\n      value: function createRenderRoot() {\n        return this.attachShadow({\n          mode: 'open'\n        });\n      }\n      /**\n       * Applies styling to the element shadowRoot using the [[`styles`]]\n       * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where\n       * available and will fallback otherwise. When Shadow DOM is polyfilled,\n       * ShadyCSS scopes styles and adds them to the document. When Shadow DOM\n       * is available but `adoptedStyleSheets` is not, styles are appended to the\n       * end of the `shadowRoot` to [mimic spec\n       * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).\n       */\n\n    }, {\n      key: \"adoptStyles\",\n      value: function adoptStyles() {\n        var styles = this.constructor._styles;\n\n        if (styles.length === 0) {\n          return;\n        } // There are three separate cases here based on Shadow DOM support.\n        // (1) shadowRoot polyfilled: use ShadyCSS\n        // (2) shadowRoot.adoptedStyleSheets available: use it\n        // (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after\n        // rendering\n\n\n        if (window.ShadyCSS !== undefined && !window.ShadyCSS.nativeShadow) {\n          window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map(function (s) {\n            return s.cssText;\n          }), this.localName);\n        } else if (supportsAdoptingStyleSheets) {\n          this.renderRoot.adoptedStyleSheets = styles.map(function (s) {\n            return s instanceof CSSStyleSheet ? s : s.styleSheet;\n          });\n        } else {\n          // This must be done after rendering so the actual style insertion is done\n          // in `update`.\n          this._needsShimAdoptedStyleSheets = true;\n        }\n      }\n    }, {\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        _get(_getPrototypeOf(LitElement.prototype), \"connectedCallback\", this).call(this); // Note, first update/render handles styleElement so we only call this if\n        // connected after first update.\n\n\n        if (this.hasUpdated && window.ShadyCSS !== undefined) {\n          window.ShadyCSS.styleElement(this);\n        }\n      }\n      /**\n       * Updates the element. This method reflects property values to attributes\n       * and calls `render` to render DOM via lit-html. Setting properties inside\n       * this method will *not* trigger another update.\n       * @param _changedProperties Map of changed properties with old values\n       */\n\n    }, {\n      key: \"update\",\n      value: function update(changedProperties) {\n        var _this = this;\n\n        // Setting properties in `render` should not trigger an update. Since\n        // updates are allowed after super.update, it's important to call `render`\n        // before that.\n        var templateResult = this.render();\n\n        _get(_getPrototypeOf(LitElement.prototype), \"update\", this).call(this, changedProperties); // If render is not implemented by the component, don't call lit-html render\n\n\n        if (templateResult !== renderNotImplemented) {\n          this.constructor.render(templateResult, this.renderRoot, {\n            scopeName: this.localName,\n            eventContext: this\n          });\n        } // When native Shadow DOM is used but adoptedStyles are not supported,\n        // insert styling after rendering to ensure adoptedStyles have highest\n        // priority.\n\n\n        if (this._needsShimAdoptedStyleSheets) {\n          this._needsShimAdoptedStyleSheets = false;\n\n          this.constructor._styles.forEach(function (s) {\n            var style = document.createElement('style');\n            style.textContent = s.cssText;\n\n            _this.renderRoot.appendChild(style);\n          });\n        }\n      }\n      /**\n       * Invoked on each update to perform rendering tasks. This method may return\n       * any value renderable by lit-html's `NodePart` - typically a\n       * `TemplateResult`. Setting properties inside this method will *not* trigger\n       * the element to update.\n       */\n\n    }, {\n      key: \"render\",\n      value: function render() {\n        return renderNotImplemented;\n      }\n    }], [{\n      key: \"getStyles\",\n      value:\n      /**\n       * Return the array of styles to apply to the element.\n       * Override this method to integrate into a style management system.\n       *\n       * @nocollapse\n       */\n      function getStyles() {\n        return this.styles;\n      }\n      /** @nocollapse */\n\n    }, {\n      key: \"_getUniqueStyles\",\n      value: function _getUniqueStyles() {\n        // Only gather styles once per class\n        if (this.hasOwnProperty(JSCompiler_renameProperty('_styles', this))) {\n          return;\n        } // Take care not to call `this.getStyles()` multiple times since this\n        // generates new CSSResults each time.\n        // TODO(sorvell): Since we do not cache CSSResults by input, any\n        // shared styles will generate new stylesheet objects, which is wasteful.\n        // This should be addressed when a browser ships constructable\n        // stylesheets.\n\n\n        var userStyles = this.getStyles();\n\n        if (Array.isArray(userStyles)) {\n          // De-duplicate styles preserving the _last_ instance in the set.\n          // This is a performance optimization to avoid duplicated styles that can\n          // occur especially when composing via subclassing.\n          // The last item is kept to try to preserve the cascade order with the\n          // assumption that it's most important that last added styles override\n          // previous styles.\n          var addStyles = function addStyles(styles, set) {\n            return styles.reduceRight(function (set, s) {\n              return (// Note: On IE set.add() does not return the set\n                Array.isArray(s) ? addStyles(s, set) : (set.add(s), set)\n              );\n            }, set);\n          }; // Array.from does not work on Set in IE, otherwise return\n          // Array.from(addStyles(userStyles, new Set<CSSResult>())).reverse()\n\n\n          var set = addStyles(userStyles, new Set());\n          var styles = [];\n          set.forEach(function (v) {\n            return styles.unshift(v);\n          });\n          this._styles = styles;\n        } else {\n          this._styles = userStyles === undefined ? [] : [userStyles];\n        } // Ensure that there are no invalid CSSStyleSheet instances here. They are\n        // invalid in two conditions.\n        // (1) the sheet is non-constructible (`sheet` of a HTMLStyleElement), but\n        //     this is impossible to check except via .replaceSync or use\n        // (2) the ShadyCSS polyfill is enabled (:. supportsAdoptingStyleSheets is\n        //     false)\n\n\n        this._styles = this._styles.map(function (s) {\n          if (s instanceof CSSStyleSheet && !supportsAdoptingStyleSheets) {\n            // Flatten the cssText from the passed constructible stylesheet (or\n            // undetectable non-constructible stylesheet). The user might have\n            // expected to update their stylesheets over time, but the alternative\n            // is a crash.\n            var cssText = Array.prototype.slice.call(s.cssRules).reduce(function (css, rule) {\n              return css + rule.cssText;\n            }, '');\n            return unsafeCSS(cssText);\n          }\n\n          return s;\n        });\n      }\n    }]);\n\n    return LitElement;\n  }(UpdatingElement);\n  /**\n   * Ensure this class is marked as `finalized` as an optimization ensuring\n   * it will not needlessly try to `finalize`.\n   *\n   * Note this property name is a string to prevent breaking Closure JS Compiler\n   * optimizations. See updating-element.ts for more information.\n   */\n\n\n  LitElement['finalized'] = true;\n  /**\n   * Reference to the underlying library method used to render the element's\n   * DOM. By default, points to the `render` method from lit-html's shady-render\n   * module.\n   *\n   * **Most users will never need to touch this property.**\n   *\n   * This  property should not be confused with the `render` instance method,\n   * which should be overridden to define a template for the element.\n   *\n   * Advanced users creating a new base class based on LitElement can override\n   * this property to point to a custom render method with a signature that\n   * matches [shady-render's `render`\n   * method](https://lit-html.polymer-project.org/api/modules/shady_render.html#render).\n   *\n   * @nocollapse\n   */\n\n  LitElement.render = render;\n  return LitElement;\n}();","map":null,"metadata":{},"sourceType":"module"}