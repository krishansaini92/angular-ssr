{"ast":null,"code":"import _slicedToArray from \"/Users/krishan/Documents/vmware/angular-ssr/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/*\n * Copyright (c) 2016-2021 VMware, Inc. All Rights Reserved.\n * This software is released under MIT license.\n * The full license information can be found in LICENSE in the root directory of this project.\n */\nimport includes from 'ramda/es/includes.js';\nimport without from 'ramda/es/without.js';\nimport { isStringAndNotNilOrEmpty } from './identity.js';\n/**\n * We are not going to be opinionated about the use of the disabled attribute here.\n * Browsers will manage that on their own. The focus of this is to determine whether\n * or not a tabindex should be set on an element to make it programmatically\n * focusable.\n *\n */\n\nexport function isFocusable(element) {\n  var elementTagName = element.tagName.toLowerCase();\n\n  switch (elementTagName) {\n    case 'input':\n    case 'button':\n    case 'select':\n    case 'textarea':\n    case 'object':\n      return true;\n\n    case 'a':\n    case 'area':\n      return element.hasAttribute('href');\n\n    case 'audio':\n    case 'video':\n      return element.hasAttribute('controls');\n\n    default:\n      // we are not going to get into invalid values sent to the\n      // tabindex attr. users have control of that and should avoid\n      // setting tabindex to weird/unsupported values.\n      return element.hasAttribute('tabindex');\n  }\n}\nexport function getElementWidth(element) {\n  var unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'px';\n\n  if (element) {\n    return element.getBoundingClientRect ? element.getBoundingClientRect().width + unit : '';\n  }\n\n  return '';\n}\nexport function getElementWidthUnless(element, unless) {\n  if (!unless) {\n    return getElementWidth(element);\n  }\n\n  return '';\n}\nexport function isHTMLElement(el) {\n  return !!el && el instanceof HTMLElement;\n}\nexport function hasAttributeAndIsNotEmpty(element, attribute) {\n  return !!element && element.hasAttribute(attribute) && isStringAndNotNilOrEmpty(element.getAttribute(attribute));\n}\nexport function setOrRemoveAttribute(element, attrTuple, test) {\n  var _attrTuple = _slicedToArray(attrTuple, 2),\n      attribute = _attrTuple[0],\n      value = _attrTuple[1];\n\n  if (test()) {\n    setAttributes(element, [attribute, value]);\n  } else {\n    removeAttributes(element, attribute);\n  }\n}\nexport function setAttributes(element) {\n  if (element) {\n    for (var _len = arguments.length, attributeTuples = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      attributeTuples[_key - 1] = arguments[_key];\n    }\n\n    attributeTuples.forEach(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          attr = _ref2[0],\n          val = _ref2[1];\n\n      if (val === false || val === null) {\n        element.removeAttribute(attr);\n      } else {\n        element.setAttribute(attr, val + '');\n      }\n    });\n  }\n}\nexport function removeAttributes(element) {\n  if (element) {\n    for (var _len2 = arguments.length, attrs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      attrs[_key2 - 1] = arguments[_key2];\n    }\n\n    attrs.forEach(function (attr) {\n      element.removeAttribute(attr);\n    });\n  }\n}\nexport function addAttributeValue(element, attr, value) {\n  if (element) {\n    var currentAttrVal = element.getAttribute(attr);\n\n    if (!currentAttrVal) {\n      element.setAttribute(attr, value);\n    } else if (!includes(value, currentAttrVal.split(' '))) {\n      // add it only if it is not already there\n      element.setAttribute(attr, currentAttrVal + ' ' + value);\n    }\n  }\n}\nexport function removeAttributeValue(element, attr, value) {\n  if (element) {\n    var currentAttrVal = element.getAttribute(attr);\n\n    if (currentAttrVal) {\n      // remove the specified value from the list of values currently set\n      var attrValues = without([value], currentAttrVal.split(' '));\n      var newAttrValue = attrValues.join(' ');\n\n      if (newAttrValue) {\n        element.setAttribute(attr, newAttrValue);\n      } else {\n        element.removeAttribute(attr);\n      }\n    }\n  }\n}\nexport function assignSlotNames() {\n  for (var _len3 = arguments.length, slotTuples = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    slotTuples[_key3] = arguments[_key3];\n  }\n\n  slotTuples.forEach(function (slotTuple) {\n    var _slotTuple = _slicedToArray(slotTuple, 2),\n        el = _slotTuple[0],\n        slotName = _slotTuple[1];\n\n    if (el) {\n      setAttributes(el, ['slot', slotName]);\n    }\n  });\n}\nexport function listenForAttributeChange(element, attrName, fn) {\n  var observer = new MutationObserver(function (mutations) {\n    if (mutations.find(function (m) {\n      return m.attributeName === attrName;\n    })) {\n      fn(element.getAttribute(attrName));\n    }\n  });\n  observer.observe(element, {\n    attributes: true\n  });\n  return observer;\n}\nexport function isVisible(element) {\n  return !!element && (element === null || element === void 0 ? void 0 : element.offsetHeight) > 0 && (element === null || element === void 0 ? void 0 : element.hasAttribute('hidden')) === false;\n}\nexport function spanWrapper(nodeList) {\n  Array.from(nodeList).filter(function (node) {\n    return node.textContent && node.textContent.trim().length > 0 && node.nodeType === 3 && node.parentElement;\n  }).forEach(function (node) {\n    var spanWrapper = document.createElement('span');\n    node.after(spanWrapper);\n    spanWrapper.appendChild(node);\n  });\n}","map":null,"metadata":{},"sourceType":"module"}